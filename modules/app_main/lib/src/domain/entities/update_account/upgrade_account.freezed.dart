// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'upgrade_account.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

UpgradeAccount _$UpgradeAccountFromJson(Map<String, dynamic> json) {
  return _UpgradeAccount.fromJson(json);
}

/// @nodoc
mixin _$UpgradeAccount {
  List<Job>? get jobs => throw _privateConstructorUsedError;
  @JsonKey(name: 'sex')
  List<Gender>? get genders => throw _privateConstructorUsedError;
  List<Protector>? get protectors => throw _privateConstructorUsedError;
  @JsonKey(name: 'blood_groups')
  List<BloodGroup>? get bloodGroups => throw _privateConstructorUsedError;
  @JsonKey(name: 'marital_status')
  List<MaritalStatus>? get maritalStatus => throw _privateConstructorUsedError;
  @JsonKey(name: 'academic_levels')
  List<AcademicLevel>? get academicLevels => throw _privateConstructorUsedError;
  List<Interest>? get interests => throw _privateConstructorUsedError;
  List<Talent>? get talents => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UpgradeAccountCopyWith<UpgradeAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpgradeAccountCopyWith<$Res> {
  factory $UpgradeAccountCopyWith(
          UpgradeAccount value, $Res Function(UpgradeAccount) then) =
      _$UpgradeAccountCopyWithImpl<$Res, UpgradeAccount>;
  @useResult
  $Res call(
      {List<Job>? jobs,
      @JsonKey(name: 'sex') List<Gender>? genders,
      List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels') List<AcademicLevel>? academicLevels,
      List<Interest>? interests,
      List<Talent>? talents});
}

/// @nodoc
class _$UpgradeAccountCopyWithImpl<$Res, $Val extends UpgradeAccount>
    implements $UpgradeAccountCopyWith<$Res> {
  _$UpgradeAccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jobs = freezed,
    Object? genders = freezed,
    Object? protectors = freezed,
    Object? bloodGroups = freezed,
    Object? maritalStatus = freezed,
    Object? academicLevels = freezed,
    Object? interests = freezed,
    Object? talents = freezed,
  }) {
    return _then(_value.copyWith(
      jobs: freezed == jobs
          ? _value.jobs
          : jobs // ignore: cast_nullable_to_non_nullable
              as List<Job>?,
      genders: freezed == genders
          ? _value.genders
          : genders // ignore: cast_nullable_to_non_nullable
              as List<Gender>?,
      protectors: freezed == protectors
          ? _value.protectors
          : protectors // ignore: cast_nullable_to_non_nullable
              as List<Protector>?,
      bloodGroups: freezed == bloodGroups
          ? _value.bloodGroups
          : bloodGroups // ignore: cast_nullable_to_non_nullable
              as List<BloodGroup>?,
      maritalStatus: freezed == maritalStatus
          ? _value.maritalStatus
          : maritalStatus // ignore: cast_nullable_to_non_nullable
              as List<MaritalStatus>?,
      academicLevels: freezed == academicLevels
          ? _value.academicLevels
          : academicLevels // ignore: cast_nullable_to_non_nullable
              as List<AcademicLevel>?,
      interests: freezed == interests
          ? _value.interests
          : interests // ignore: cast_nullable_to_non_nullable
              as List<Interest>?,
      talents: freezed == talents
          ? _value.talents
          : talents // ignore: cast_nullable_to_non_nullable
              as List<Talent>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UpgradeAccountCopyWith<$Res>
    implements $UpgradeAccountCopyWith<$Res> {
  factory _$$_UpgradeAccountCopyWith(
          _$_UpgradeAccount value, $Res Function(_$_UpgradeAccount) then) =
      __$$_UpgradeAccountCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Job>? jobs,
      @JsonKey(name: 'sex') List<Gender>? genders,
      List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels') List<AcademicLevel>? academicLevels,
      List<Interest>? interests,
      List<Talent>? talents});
}

/// @nodoc
class __$$_UpgradeAccountCopyWithImpl<$Res>
    extends _$UpgradeAccountCopyWithImpl<$Res, _$_UpgradeAccount>
    implements _$$_UpgradeAccountCopyWith<$Res> {
  __$$_UpgradeAccountCopyWithImpl(
      _$_UpgradeAccount _value, $Res Function(_$_UpgradeAccount) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jobs = freezed,
    Object? genders = freezed,
    Object? protectors = freezed,
    Object? bloodGroups = freezed,
    Object? maritalStatus = freezed,
    Object? academicLevels = freezed,
    Object? interests = freezed,
    Object? talents = freezed,
  }) {
    return _then(_$_UpgradeAccount(
      jobs: freezed == jobs
          ? _value._jobs
          : jobs // ignore: cast_nullable_to_non_nullable
              as List<Job>?,
      genders: freezed == genders
          ? _value._genders
          : genders // ignore: cast_nullable_to_non_nullable
              as List<Gender>?,
      protectors: freezed == protectors
          ? _value._protectors
          : protectors // ignore: cast_nullable_to_non_nullable
              as List<Protector>?,
      bloodGroups: freezed == bloodGroups
          ? _value._bloodGroups
          : bloodGroups // ignore: cast_nullable_to_non_nullable
              as List<BloodGroup>?,
      maritalStatus: freezed == maritalStatus
          ? _value._maritalStatus
          : maritalStatus // ignore: cast_nullable_to_non_nullable
              as List<MaritalStatus>?,
      academicLevels: freezed == academicLevels
          ? _value._academicLevels
          : academicLevels // ignore: cast_nullable_to_non_nullable
              as List<AcademicLevel>?,
      interests: freezed == interests
          ? _value._interests
          : interests // ignore: cast_nullable_to_non_nullable
              as List<Interest>?,
      talents: freezed == talents
          ? _value._talents
          : talents // ignore: cast_nullable_to_non_nullable
              as List<Talent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpgradeAccount implements _UpgradeAccount {
  const _$_UpgradeAccount(
      {final List<Job>? jobs,
      @JsonKey(name: 'sex') final List<Gender>? genders,
      final List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') final List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') final List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels')
      final List<AcademicLevel>? academicLevels,
      final List<Interest>? interests,
      final List<Talent>? talents})
      : _jobs = jobs,
        _genders = genders,
        _protectors = protectors,
        _bloodGroups = bloodGroups,
        _maritalStatus = maritalStatus,
        _academicLevels = academicLevels,
        _interests = interests,
        _talents = talents;

  factory _$_UpgradeAccount.fromJson(Map<String, dynamic> json) =>
      _$$_UpgradeAccountFromJson(json);

  final List<Job>? _jobs;
  @override
  List<Job>? get jobs {
    final value = _jobs;
    if (value == null) return null;
    if (_jobs is EqualUnmodifiableListView) return _jobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Gender>? _genders;
  @override
  @JsonKey(name: 'sex')
  List<Gender>? get genders {
    final value = _genders;
    if (value == null) return null;
    if (_genders is EqualUnmodifiableListView) return _genders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Protector>? _protectors;
  @override
  List<Protector>? get protectors {
    final value = _protectors;
    if (value == null) return null;
    if (_protectors is EqualUnmodifiableListView) return _protectors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<BloodGroup>? _bloodGroups;
  @override
  @JsonKey(name: 'blood_groups')
  List<BloodGroup>? get bloodGroups {
    final value = _bloodGroups;
    if (value == null) return null;
    if (_bloodGroups is EqualUnmodifiableListView) return _bloodGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<MaritalStatus>? _maritalStatus;
  @override
  @JsonKey(name: 'marital_status')
  List<MaritalStatus>? get maritalStatus {
    final value = _maritalStatus;
    if (value == null) return null;
    if (_maritalStatus is EqualUnmodifiableListView) return _maritalStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<AcademicLevel>? _academicLevels;
  @override
  @JsonKey(name: 'academic_levels')
  List<AcademicLevel>? get academicLevels {
    final value = _academicLevels;
    if (value == null) return null;
    if (_academicLevels is EqualUnmodifiableListView) return _academicLevels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Interest>? _interests;
  @override
  List<Interest>? get interests {
    final value = _interests;
    if (value == null) return null;
    if (_interests is EqualUnmodifiableListView) return _interests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Talent>? _talents;
  @override
  List<Talent>? get talents {
    final value = _talents;
    if (value == null) return null;
    if (_talents is EqualUnmodifiableListView) return _talents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'UpgradeAccount(jobs: $jobs, genders: $genders, protectors: $protectors, bloodGroups: $bloodGroups, maritalStatus: $maritalStatus, academicLevels: $academicLevels, interests: $interests, talents: $talents)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpgradeAccount &&
            const DeepCollectionEquality().equals(other._jobs, _jobs) &&
            const DeepCollectionEquality().equals(other._genders, _genders) &&
            const DeepCollectionEquality()
                .equals(other._protectors, _protectors) &&
            const DeepCollectionEquality()
                .equals(other._bloodGroups, _bloodGroups) &&
            const DeepCollectionEquality()
                .equals(other._maritalStatus, _maritalStatus) &&
            const DeepCollectionEquality()
                .equals(other._academicLevels, _academicLevels) &&
            const DeepCollectionEquality()
                .equals(other._interests, _interests) &&
            const DeepCollectionEquality().equals(other._talents, _talents));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_jobs),
      const DeepCollectionEquality().hash(_genders),
      const DeepCollectionEquality().hash(_protectors),
      const DeepCollectionEquality().hash(_bloodGroups),
      const DeepCollectionEquality().hash(_maritalStatus),
      const DeepCollectionEquality().hash(_academicLevels),
      const DeepCollectionEquality().hash(_interests),
      const DeepCollectionEquality().hash(_talents));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpgradeAccountCopyWith<_$_UpgradeAccount> get copyWith =>
      __$$_UpgradeAccountCopyWithImpl<_$_UpgradeAccount>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpgradeAccountToJson(
      this,
    );
  }
}

abstract class _UpgradeAccount implements UpgradeAccount {
  const factory _UpgradeAccount(
      {final List<Job>? jobs,
      @JsonKey(name: 'sex') final List<Gender>? genders,
      final List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') final List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') final List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels')
      final List<AcademicLevel>? academicLevels,
      final List<Interest>? interests,
      final List<Talent>? talents}) = _$_UpgradeAccount;

  factory _UpgradeAccount.fromJson(Map<String, dynamic> json) =
      _$_UpgradeAccount.fromJson;

  @override
  List<Job>? get jobs;
  @override
  @JsonKey(name: 'sex')
  List<Gender>? get genders;
  @override
  List<Protector>? get protectors;
  @override
  @JsonKey(name: 'blood_groups')
  List<BloodGroup>? get bloodGroups;
  @override
  @JsonKey(name: 'marital_status')
  List<MaritalStatus>? get maritalStatus;
  @override
  @JsonKey(name: 'academic_levels')
  List<AcademicLevel>? get academicLevels;
  @override
  List<Interest>? get interests;
  @override
  List<Talent>? get talents;
  @override
  @JsonKey(ignore: true)
  _$$_UpgradeAccountCopyWith<_$_UpgradeAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

Job _$JobFromJson(Map<String, dynamic> json) {
  return _Job.fromJson(json);
}

/// @nodoc
mixin _$Job {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $JobCopyWith<Job> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $JobCopyWith<$Res> {
  factory $JobCopyWith(Job value, $Res Function(Job) then) =
      _$JobCopyWithImpl<$Res, Job>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$JobCopyWithImpl<$Res, $Val extends Job> implements $JobCopyWith<$Res> {
  _$JobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_JobCopyWith<$Res> implements $JobCopyWith<$Res> {
  factory _$$_JobCopyWith(_$_Job value, $Res Function(_$_Job) then) =
      __$$_JobCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$_JobCopyWithImpl<$Res> extends _$JobCopyWithImpl<$Res, _$_Job>
    implements _$$_JobCopyWith<$Res> {
  __$$_JobCopyWithImpl(_$_Job _value, $Res Function(_$_Job) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_Job(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Job implements _Job {
  const _$_Job({this.key, this.name});

  factory _$_Job.fromJson(Map<String, dynamic> json) => _$$_JobFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'Job(key: $key, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Job &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_JobCopyWith<_$_Job> get copyWith =>
      __$$_JobCopyWithImpl<_$_Job>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_JobToJson(
      this,
    );
  }
}

abstract class _Job implements Job {
  const factory _Job({final String? key, final String? name}) = _$_Job;

  factory _Job.fromJson(Map<String, dynamic> json) = _$_Job.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_JobCopyWith<_$_Job> get copyWith => throw _privateConstructorUsedError;
}

Gender _$GenderFromJson(Map<String, dynamic> json) {
  return _Gender.fromJson(json);
}

/// @nodoc
mixin _$Gender {
  int? get key => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GenderCopyWith<Gender> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenderCopyWith<$Res> {
  factory $GenderCopyWith(Gender value, $Res Function(Gender) then) =
      _$GenderCopyWithImpl<$Res, Gender>;
  @useResult
  $Res call({int? key, String? value});
}

/// @nodoc
class _$GenderCopyWithImpl<$Res, $Val extends Gender>
    implements $GenderCopyWith<$Res> {
  _$GenderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GenderCopyWith<$Res> implements $GenderCopyWith<$Res> {
  factory _$$_GenderCopyWith(_$_Gender value, $Res Function(_$_Gender) then) =
      __$$_GenderCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? key, String? value});
}

/// @nodoc
class __$$_GenderCopyWithImpl<$Res>
    extends _$GenderCopyWithImpl<$Res, _$_Gender>
    implements _$$_GenderCopyWith<$Res> {
  __$$_GenderCopyWithImpl(_$_Gender _value, $Res Function(_$_Gender) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
  }) {
    return _then(_$_Gender(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Gender implements _Gender {
  const _$_Gender({this.key, this.value});

  factory _$_Gender.fromJson(Map<String, dynamic> json) =>
      _$$_GenderFromJson(json);

  @override
  final int? key;
  @override
  final String? value;

  @override
  String toString() {
    return 'Gender(key: $key, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Gender &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GenderCopyWith<_$_Gender> get copyWith =>
      __$$_GenderCopyWithImpl<_$_Gender>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GenderToJson(
      this,
    );
  }
}

abstract class _Gender implements Gender {
  const factory _Gender({final int? key, final String? value}) = _$_Gender;

  factory _Gender.fromJson(Map<String, dynamic> json) = _$_Gender.fromJson;

  @override
  int? get key;
  @override
  String? get value;
  @override
  @JsonKey(ignore: true)
  _$$_GenderCopyWith<_$_Gender> get copyWith =>
      throw _privateConstructorUsedError;
}

Protector _$ProtectorFromJson(Map<String, dynamic> json) {
  return _Protector.fromJson(json);
}

/// @nodoc
mixin _$Protector {
  int? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ProtectorCopyWith<Protector> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProtectorCopyWith<$Res> {
  factory $ProtectorCopyWith(Protector value, $Res Function(Protector) then) =
      _$ProtectorCopyWithImpl<$Res, Protector>;
  @useResult
  $Res call({int? id, String? name});
}

/// @nodoc
class _$ProtectorCopyWithImpl<$Res, $Val extends Protector>
    implements $ProtectorCopyWith<$Res> {
  _$ProtectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ProtectorCopyWith<$Res> implements $ProtectorCopyWith<$Res> {
  factory _$$_ProtectorCopyWith(
          _$_Protector value, $Res Function(_$_Protector) then) =
      __$$_ProtectorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? id, String? name});
}

/// @nodoc
class __$$_ProtectorCopyWithImpl<$Res>
    extends _$ProtectorCopyWithImpl<$Res, _$_Protector>
    implements _$$_ProtectorCopyWith<$Res> {
  __$$_ProtectorCopyWithImpl(
      _$_Protector _value, $Res Function(_$_Protector) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_Protector(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Protector implements _Protector {
  const _$_Protector({this.id, this.name});

  factory _$_Protector.fromJson(Map<String, dynamic> json) =>
      _$$_ProtectorFromJson(json);

  @override
  final int? id;
  @override
  final String? name;

  @override
  String toString() {
    return 'Protector(id: $id, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Protector &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ProtectorCopyWith<_$_Protector> get copyWith =>
      __$$_ProtectorCopyWithImpl<_$_Protector>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ProtectorToJson(
      this,
    );
  }
}

abstract class _Protector implements Protector {
  const factory _Protector({final int? id, final String? name}) = _$_Protector;

  factory _Protector.fromJson(Map<String, dynamic> json) =
      _$_Protector.fromJson;

  @override
  int? get id;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_ProtectorCopyWith<_$_Protector> get copyWith =>
      throw _privateConstructorUsedError;
}

BloodGroup _$BloodGroupFromJson(Map<String, dynamic> json) {
  return _BloodGroup.fromJson(json);
}

/// @nodoc
mixin _$BloodGroup {
  String? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BloodGroupCopyWith<BloodGroup> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BloodGroupCopyWith<$Res> {
  factory $BloodGroupCopyWith(
          BloodGroup value, $Res Function(BloodGroup) then) =
      _$BloodGroupCopyWithImpl<$Res, BloodGroup>;
  @useResult
  $Res call({String? id, String? name});
}

/// @nodoc
class _$BloodGroupCopyWithImpl<$Res, $Val extends BloodGroup>
    implements $BloodGroupCopyWith<$Res> {
  _$BloodGroupCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BloodGroupCopyWith<$Res>
    implements $BloodGroupCopyWith<$Res> {
  factory _$$_BloodGroupCopyWith(
          _$_BloodGroup value, $Res Function(_$_BloodGroup) then) =
      __$$_BloodGroupCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? id, String? name});
}

/// @nodoc
class __$$_BloodGroupCopyWithImpl<$Res>
    extends _$BloodGroupCopyWithImpl<$Res, _$_BloodGroup>
    implements _$$_BloodGroupCopyWith<$Res> {
  __$$_BloodGroupCopyWithImpl(
      _$_BloodGroup _value, $Res Function(_$_BloodGroup) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_BloodGroup(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BloodGroup implements _BloodGroup {
  const _$_BloodGroup({this.id, this.name});

  factory _$_BloodGroup.fromJson(Map<String, dynamic> json) =>
      _$$_BloodGroupFromJson(json);

  @override
  final String? id;
  @override
  final String? name;

  @override
  String toString() {
    return 'BloodGroup(id: $id, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BloodGroup &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BloodGroupCopyWith<_$_BloodGroup> get copyWith =>
      __$$_BloodGroupCopyWithImpl<_$_BloodGroup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BloodGroupToJson(
      this,
    );
  }
}

abstract class _BloodGroup implements BloodGroup {
  const factory _BloodGroup({final String? id, final String? name}) =
      _$_BloodGroup;

  factory _BloodGroup.fromJson(Map<String, dynamic> json) =
      _$_BloodGroup.fromJson;

  @override
  String? get id;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_BloodGroupCopyWith<_$_BloodGroup> get copyWith =>
      throw _privateConstructorUsedError;
}

MaritalStatus _$MaritalStatusFromJson(Map<String, dynamic> json) {
  return _MaritalStatus.fromJson(json);
}

/// @nodoc
mixin _$MaritalStatus {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MaritalStatusCopyWith<MaritalStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaritalStatusCopyWith<$Res> {
  factory $MaritalStatusCopyWith(
          MaritalStatus value, $Res Function(MaritalStatus) then) =
      _$MaritalStatusCopyWithImpl<$Res, MaritalStatus>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$MaritalStatusCopyWithImpl<$Res, $Val extends MaritalStatus>
    implements $MaritalStatusCopyWith<$Res> {
  _$MaritalStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MaritalStatusCopyWith<$Res>
    implements $MaritalStatusCopyWith<$Res> {
  factory _$$_MaritalStatusCopyWith(
          _$_MaritalStatus value, $Res Function(_$_MaritalStatus) then) =
      __$$_MaritalStatusCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$_MaritalStatusCopyWithImpl<$Res>
    extends _$MaritalStatusCopyWithImpl<$Res, _$_MaritalStatus>
    implements _$$_MaritalStatusCopyWith<$Res> {
  __$$_MaritalStatusCopyWithImpl(
      _$_MaritalStatus _value, $Res Function(_$_MaritalStatus) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_MaritalStatus(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MaritalStatus implements _MaritalStatus {
  const _$_MaritalStatus({this.key, this.name});

  factory _$_MaritalStatus.fromJson(Map<String, dynamic> json) =>
      _$$_MaritalStatusFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'MaritalStatus(key: $key, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MaritalStatus &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MaritalStatusCopyWith<_$_MaritalStatus> get copyWith =>
      __$$_MaritalStatusCopyWithImpl<_$_MaritalStatus>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MaritalStatusToJson(
      this,
    );
  }
}

abstract class _MaritalStatus implements MaritalStatus {
  const factory _MaritalStatus({final String? key, final String? name}) =
      _$_MaritalStatus;

  factory _MaritalStatus.fromJson(Map<String, dynamic> json) =
      _$_MaritalStatus.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_MaritalStatusCopyWith<_$_MaritalStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

AcademicLevel _$AcademicLevelFromJson(Map<String, dynamic> json) {
  return _AcademicLevel.fromJson(json);
}

/// @nodoc
mixin _$AcademicLevel {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AcademicLevelCopyWith<AcademicLevel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AcademicLevelCopyWith<$Res> {
  factory $AcademicLevelCopyWith(
          AcademicLevel value, $Res Function(AcademicLevel) then) =
      _$AcademicLevelCopyWithImpl<$Res, AcademicLevel>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$AcademicLevelCopyWithImpl<$Res, $Val extends AcademicLevel>
    implements $AcademicLevelCopyWith<$Res> {
  _$AcademicLevelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AcademicLevelCopyWith<$Res>
    implements $AcademicLevelCopyWith<$Res> {
  factory _$$_AcademicLevelCopyWith(
          _$_AcademicLevel value, $Res Function(_$_AcademicLevel) then) =
      __$$_AcademicLevelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$_AcademicLevelCopyWithImpl<$Res>
    extends _$AcademicLevelCopyWithImpl<$Res, _$_AcademicLevel>
    implements _$$_AcademicLevelCopyWith<$Res> {
  __$$_AcademicLevelCopyWithImpl(
      _$_AcademicLevel _value, $Res Function(_$_AcademicLevel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_AcademicLevel(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AcademicLevel implements _AcademicLevel {
  const _$_AcademicLevel({this.key, this.name});

  factory _$_AcademicLevel.fromJson(Map<String, dynamic> json) =>
      _$$_AcademicLevelFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'AcademicLevel(key: $key, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AcademicLevel &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AcademicLevelCopyWith<_$_AcademicLevel> get copyWith =>
      __$$_AcademicLevelCopyWithImpl<_$_AcademicLevel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AcademicLevelToJson(
      this,
    );
  }
}

abstract class _AcademicLevel implements AcademicLevel {
  const factory _AcademicLevel({final String? key, final String? name}) =
      _$_AcademicLevel;

  factory _AcademicLevel.fromJson(Map<String, dynamic> json) =
      _$_AcademicLevel.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_AcademicLevelCopyWith<_$_AcademicLevel> get copyWith =>
      throw _privateConstructorUsedError;
}

Interest _$InterestFromJson(Map<String, dynamic> json) {
  return _Interest.fromJson(json);
}

/// @nodoc
mixin _$Interest {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InterestCopyWith<Interest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InterestCopyWith<$Res> {
  factory $InterestCopyWith(Interest value, $Res Function(Interest) then) =
      _$InterestCopyWithImpl<$Res, Interest>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$InterestCopyWithImpl<$Res, $Val extends Interest>
    implements $InterestCopyWith<$Res> {
  _$InterestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_InterestCopyWith<$Res> implements $InterestCopyWith<$Res> {
  factory _$$_InterestCopyWith(
          _$_Interest value, $Res Function(_$_Interest) then) =
      __$$_InterestCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$_InterestCopyWithImpl<$Res>
    extends _$InterestCopyWithImpl<$Res, _$_Interest>
    implements _$$_InterestCopyWith<$Res> {
  __$$_InterestCopyWithImpl(
      _$_Interest _value, $Res Function(_$_Interest) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_Interest(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Interest implements _Interest {
  const _$_Interest({this.key, this.name});

  factory _$_Interest.fromJson(Map<String, dynamic> json) =>
      _$$_InterestFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'Interest(key: $key, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Interest &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InterestCopyWith<_$_Interest> get copyWith =>
      __$$_InterestCopyWithImpl<_$_Interest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InterestToJson(
      this,
    );
  }
}

abstract class _Interest implements Interest {
  const factory _Interest({final String? key, final String? name}) =
      _$_Interest;

  factory _Interest.fromJson(Map<String, dynamic> json) = _$_Interest.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_InterestCopyWith<_$_Interest> get copyWith =>
      throw _privateConstructorUsedError;
}

Talent _$TalentFromJson(Map<String, dynamic> json) {
  return _Talent.fromJson(json);
}

/// @nodoc
mixin _$Talent {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TalentCopyWith<Talent> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TalentCopyWith<$Res> {
  factory $TalentCopyWith(Talent value, $Res Function(Talent) then) =
      _$TalentCopyWithImpl<$Res, Talent>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$TalentCopyWithImpl<$Res, $Val extends Talent>
    implements $TalentCopyWith<$Res> {
  _$TalentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TalentCopyWith<$Res> implements $TalentCopyWith<$Res> {
  factory _$$_TalentCopyWith(_$_Talent value, $Res Function(_$_Talent) then) =
      __$$_TalentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$_TalentCopyWithImpl<$Res>
    extends _$TalentCopyWithImpl<$Res, _$_Talent>
    implements _$$_TalentCopyWith<$Res> {
  __$$_TalentCopyWithImpl(_$_Talent _value, $Res Function(_$_Talent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_Talent(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Talent implements _Talent {
  const _$_Talent({this.key, this.name});

  factory _$_Talent.fromJson(Map<String, dynamic> json) =>
      _$$_TalentFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'Talent(key: $key, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Talent &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TalentCopyWith<_$_Talent> get copyWith =>
      __$$_TalentCopyWithImpl<_$_Talent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TalentToJson(
      this,
    );
  }
}

abstract class _Talent implements Talent {
  const factory _Talent({final String? key, final String? name}) = _$_Talent;

  factory _Talent.fromJson(Map<String, dynamic> json) = _$_Talent.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_TalentCopyWith<_$_Talent> get copyWith =>
      throw _privateConstructorUsedError;
}
