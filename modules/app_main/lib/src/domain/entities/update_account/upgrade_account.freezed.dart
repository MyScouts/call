// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'upgrade_account.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

UpgradeAccount _$UpgradeAccountFromJson(Map<String, dynamic> json) {
  return _UpgradeAccount.fromJson(json);
}

/// @nodoc
mixin _$UpgradeAccount {
  List<Job>? get jobs => throw _privateConstructorUsedError;
  @JsonKey(name: 'sex')
  List<Gender>? get genders => throw _privateConstructorUsedError;
  List<Protector>? get protectors => throw _privateConstructorUsedError;
  @JsonKey(name: 'blood_groups')
  List<BloodGroup>? get bloodGroups => throw _privateConstructorUsedError;
  @JsonKey(name: 'marital_status')
  List<MaritalStatus>? get maritalStatus => throw _privateConstructorUsedError;
  @JsonKey(name: 'academic_levels')
  List<AcademicLevel>? get academicLevels => throw _privateConstructorUsedError;
  List<Interest>? get interests => throw _privateConstructorUsedError;
  List<Talent>? get talents => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UpgradeAccountCopyWith<UpgradeAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpgradeAccountCopyWith<$Res> {
  factory $UpgradeAccountCopyWith(
          UpgradeAccount value, $Res Function(UpgradeAccount) then) =
      _$UpgradeAccountCopyWithImpl<$Res, UpgradeAccount>;
  @useResult
  $Res call(
      {List<Job>? jobs,
      @JsonKey(name: 'sex') List<Gender>? genders,
      List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels') List<AcademicLevel>? academicLevels,
      List<Interest>? interests,
      List<Talent>? talents});
}

/// @nodoc
class _$UpgradeAccountCopyWithImpl<$Res, $Val extends UpgradeAccount>
    implements $UpgradeAccountCopyWith<$Res> {
  _$UpgradeAccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jobs = freezed,
    Object? genders = freezed,
    Object? protectors = freezed,
    Object? bloodGroups = freezed,
    Object? maritalStatus = freezed,
    Object? academicLevels = freezed,
    Object? interests = freezed,
    Object? talents = freezed,
  }) {
    return _then(_value.copyWith(
      jobs: freezed == jobs
          ? _value.jobs
          : jobs // ignore: cast_nullable_to_non_nullable
              as List<Job>?,
      genders: freezed == genders
          ? _value.genders
          : genders // ignore: cast_nullable_to_non_nullable
              as List<Gender>?,
      protectors: freezed == protectors
          ? _value.protectors
          : protectors // ignore: cast_nullable_to_non_nullable
              as List<Protector>?,
      bloodGroups: freezed == bloodGroups
          ? _value.bloodGroups
          : bloodGroups // ignore: cast_nullable_to_non_nullable
              as List<BloodGroup>?,
      maritalStatus: freezed == maritalStatus
          ? _value.maritalStatus
          : maritalStatus // ignore: cast_nullable_to_non_nullable
              as List<MaritalStatus>?,
      academicLevels: freezed == academicLevels
          ? _value.academicLevels
          : academicLevels // ignore: cast_nullable_to_non_nullable
              as List<AcademicLevel>?,
      interests: freezed == interests
          ? _value.interests
          : interests // ignore: cast_nullable_to_non_nullable
              as List<Interest>?,
      talents: freezed == talents
          ? _value.talents
          : talents // ignore: cast_nullable_to_non_nullable
              as List<Talent>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UpgradeAccountImplCopyWith<$Res>
    implements $UpgradeAccountCopyWith<$Res> {
  factory _$$UpgradeAccountImplCopyWith(_$UpgradeAccountImpl value,
          $Res Function(_$UpgradeAccountImpl) then) =
      __$$UpgradeAccountImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Job>? jobs,
      @JsonKey(name: 'sex') List<Gender>? genders,
      List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels') List<AcademicLevel>? academicLevels,
      List<Interest>? interests,
      List<Talent>? talents});
}

/// @nodoc
class __$$UpgradeAccountImplCopyWithImpl<$Res>
    extends _$UpgradeAccountCopyWithImpl<$Res, _$UpgradeAccountImpl>
    implements _$$UpgradeAccountImplCopyWith<$Res> {
  __$$UpgradeAccountImplCopyWithImpl(
      _$UpgradeAccountImpl _value, $Res Function(_$UpgradeAccountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jobs = freezed,
    Object? genders = freezed,
    Object? protectors = freezed,
    Object? bloodGroups = freezed,
    Object? maritalStatus = freezed,
    Object? academicLevels = freezed,
    Object? interests = freezed,
    Object? talents = freezed,
  }) {
    return _then(_$UpgradeAccountImpl(
      jobs: freezed == jobs
          ? _value._jobs
          : jobs // ignore: cast_nullable_to_non_nullable
              as List<Job>?,
      genders: freezed == genders
          ? _value._genders
          : genders // ignore: cast_nullable_to_non_nullable
              as List<Gender>?,
      protectors: freezed == protectors
          ? _value._protectors
          : protectors // ignore: cast_nullable_to_non_nullable
              as List<Protector>?,
      bloodGroups: freezed == bloodGroups
          ? _value._bloodGroups
          : bloodGroups // ignore: cast_nullable_to_non_nullable
              as List<BloodGroup>?,
      maritalStatus: freezed == maritalStatus
          ? _value._maritalStatus
          : maritalStatus // ignore: cast_nullable_to_non_nullable
              as List<MaritalStatus>?,
      academicLevels: freezed == academicLevels
          ? _value._academicLevels
          : academicLevels // ignore: cast_nullable_to_non_nullable
              as List<AcademicLevel>?,
      interests: freezed == interests
          ? _value._interests
          : interests // ignore: cast_nullable_to_non_nullable
              as List<Interest>?,
      talents: freezed == talents
          ? _value._talents
          : talents // ignore: cast_nullable_to_non_nullable
              as List<Talent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UpgradeAccountImpl implements _UpgradeAccount {
  const _$UpgradeAccountImpl(
      {final List<Job>? jobs,
      @JsonKey(name: 'sex') final List<Gender>? genders,
      final List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') final List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') final List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels')
      final List<AcademicLevel>? academicLevels,
      final List<Interest>? interests,
      final List<Talent>? talents})
      : _jobs = jobs,
        _genders = genders,
        _protectors = protectors,
        _bloodGroups = bloodGroups,
        _maritalStatus = maritalStatus,
        _academicLevels = academicLevels,
        _interests = interests,
        _talents = talents;

  factory _$UpgradeAccountImpl.fromJson(Map<String, dynamic> json) =>
      _$$UpgradeAccountImplFromJson(json);

  final List<Job>? _jobs;
  @override
  List<Job>? get jobs {
    final value = _jobs;
    if (value == null) return null;
    if (_jobs is EqualUnmodifiableListView) return _jobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Gender>? _genders;
  @override
  @JsonKey(name: 'sex')
  List<Gender>? get genders {
    final value = _genders;
    if (value == null) return null;
    if (_genders is EqualUnmodifiableListView) return _genders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Protector>? _protectors;
  @override
  List<Protector>? get protectors {
    final value = _protectors;
    if (value == null) return null;
    if (_protectors is EqualUnmodifiableListView) return _protectors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<BloodGroup>? _bloodGroups;
  @override
  @JsonKey(name: 'blood_groups')
  List<BloodGroup>? get bloodGroups {
    final value = _bloodGroups;
    if (value == null) return null;
    if (_bloodGroups is EqualUnmodifiableListView) return _bloodGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<MaritalStatus>? _maritalStatus;
  @override
  @JsonKey(name: 'marital_status')
  List<MaritalStatus>? get maritalStatus {
    final value = _maritalStatus;
    if (value == null) return null;
    if (_maritalStatus is EqualUnmodifiableListView) return _maritalStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<AcademicLevel>? _academicLevels;
  @override
  @JsonKey(name: 'academic_levels')
  List<AcademicLevel>? get academicLevels {
    final value = _academicLevels;
    if (value == null) return null;
    if (_academicLevels is EqualUnmodifiableListView) return _academicLevels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Interest>? _interests;
  @override
  List<Interest>? get interests {
    final value = _interests;
    if (value == null) return null;
    if (_interests is EqualUnmodifiableListView) return _interests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Talent>? _talents;
  @override
  List<Talent>? get talents {
    final value = _talents;
    if (value == null) return null;
    if (_talents is EqualUnmodifiableListView) return _talents;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'UpgradeAccount(jobs: $jobs, genders: $genders, protectors: $protectors, bloodGroups: $bloodGroups, maritalStatus: $maritalStatus, academicLevels: $academicLevels, interests: $interests, talents: $talents)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpgradeAccountImpl &&
            const DeepCollectionEquality().equals(other._jobs, _jobs) &&
            const DeepCollectionEquality().equals(other._genders, _genders) &&
            const DeepCollectionEquality()
                .equals(other._protectors, _protectors) &&
            const DeepCollectionEquality()
                .equals(other._bloodGroups, _bloodGroups) &&
            const DeepCollectionEquality()
                .equals(other._maritalStatus, _maritalStatus) &&
            const DeepCollectionEquality()
                .equals(other._academicLevels, _academicLevels) &&
            const DeepCollectionEquality()
                .equals(other._interests, _interests) &&
            const DeepCollectionEquality().equals(other._talents, _talents));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_jobs),
      const DeepCollectionEquality().hash(_genders),
      const DeepCollectionEquality().hash(_protectors),
      const DeepCollectionEquality().hash(_bloodGroups),
      const DeepCollectionEquality().hash(_maritalStatus),
      const DeepCollectionEquality().hash(_academicLevels),
      const DeepCollectionEquality().hash(_interests),
      const DeepCollectionEquality().hash(_talents));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpgradeAccountImplCopyWith<_$UpgradeAccountImpl> get copyWith =>
      __$$UpgradeAccountImplCopyWithImpl<_$UpgradeAccountImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UpgradeAccountImplToJson(
      this,
    );
  }
}

abstract class _UpgradeAccount implements UpgradeAccount {
  const factory _UpgradeAccount(
      {final List<Job>? jobs,
      @JsonKey(name: 'sex') final List<Gender>? genders,
      final List<Protector>? protectors,
      @JsonKey(name: 'blood_groups') final List<BloodGroup>? bloodGroups,
      @JsonKey(name: 'marital_status') final List<MaritalStatus>? maritalStatus,
      @JsonKey(name: 'academic_levels')
      final List<AcademicLevel>? academicLevels,
      final List<Interest>? interests,
      final List<Talent>? talents}) = _$UpgradeAccountImpl;

  factory _UpgradeAccount.fromJson(Map<String, dynamic> json) =
      _$UpgradeAccountImpl.fromJson;

  @override
  List<Job>? get jobs;
  @override
  @JsonKey(name: 'sex')
  List<Gender>? get genders;
  @override
  List<Protector>? get protectors;
  @override
  @JsonKey(name: 'blood_groups')
  List<BloodGroup>? get bloodGroups;
  @override
  @JsonKey(name: 'marital_status')
  List<MaritalStatus>? get maritalStatus;
  @override
  @JsonKey(name: 'academic_levels')
  List<AcademicLevel>? get academicLevels;
  @override
  List<Interest>? get interests;
  @override
  List<Talent>? get talents;
  @override
  @JsonKey(ignore: true)
  _$$UpgradeAccountImplCopyWith<_$UpgradeAccountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Job _$JobFromJson(Map<String, dynamic> json) {
  return _Job.fromJson(json);
}

/// @nodoc
mixin _$Job {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $JobCopyWith<Job> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $JobCopyWith<$Res> {
  factory $JobCopyWith(Job value, $Res Function(Job) then) =
      _$JobCopyWithImpl<$Res, Job>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$JobCopyWithImpl<$Res, $Val extends Job> implements $JobCopyWith<$Res> {
  _$JobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$JobImplCopyWith<$Res> implements $JobCopyWith<$Res> {
  factory _$$JobImplCopyWith(_$JobImpl value, $Res Function(_$JobImpl) then) =
      __$$JobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$JobImplCopyWithImpl<$Res> extends _$JobCopyWithImpl<$Res, _$JobImpl>
    implements _$$JobImplCopyWith<$Res> {
  __$$JobImplCopyWithImpl(_$JobImpl _value, $Res Function(_$JobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$JobImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$JobImpl implements _Job {
  const _$JobImpl({this.key, this.name});

  factory _$JobImpl.fromJson(Map<String, dynamic> json) =>
      _$$JobImplFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'Job(key: $key, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JobImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JobImplCopyWith<_$JobImpl> get copyWith =>
      __$$JobImplCopyWithImpl<_$JobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$JobImplToJson(
      this,
    );
  }
}

abstract class _Job implements Job {
  const factory _Job({final String? key, final String? name}) = _$JobImpl;

  factory _Job.fromJson(Map<String, dynamic> json) = _$JobImpl.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$JobImplCopyWith<_$JobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Gender _$GenderFromJson(Map<String, dynamic> json) {
  return _Gender.fromJson(json);
}

/// @nodoc
mixin _$Gender {
  int? get key => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GenderCopyWith<Gender> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenderCopyWith<$Res> {
  factory $GenderCopyWith(Gender value, $Res Function(Gender) then) =
      _$GenderCopyWithImpl<$Res, Gender>;
  @useResult
  $Res call({int? key, String? value});
}

/// @nodoc
class _$GenderCopyWithImpl<$Res, $Val extends Gender>
    implements $GenderCopyWith<$Res> {
  _$GenderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GenderImplCopyWith<$Res> implements $GenderCopyWith<$Res> {
  factory _$$GenderImplCopyWith(
          _$GenderImpl value, $Res Function(_$GenderImpl) then) =
      __$$GenderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? key, String? value});
}

/// @nodoc
class __$$GenderImplCopyWithImpl<$Res>
    extends _$GenderCopyWithImpl<$Res, _$GenderImpl>
    implements _$$GenderImplCopyWith<$Res> {
  __$$GenderImplCopyWithImpl(
      _$GenderImpl _value, $Res Function(_$GenderImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
  }) {
    return _then(_$GenderImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GenderImpl implements _Gender {
  const _$GenderImpl({this.key, this.value});

  factory _$GenderImpl.fromJson(Map<String, dynamic> json) =>
      _$$GenderImplFromJson(json);

  @override
  final int? key;
  @override
  final String? value;

  @override
  String toString() {
    return 'Gender(key: $key, value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenderImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GenderImplCopyWith<_$GenderImpl> get copyWith =>
      __$$GenderImplCopyWithImpl<_$GenderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GenderImplToJson(
      this,
    );
  }
}

abstract class _Gender implements Gender {
  const factory _Gender({final int? key, final String? value}) = _$GenderImpl;

  factory _Gender.fromJson(Map<String, dynamic> json) = _$GenderImpl.fromJson;

  @override
  int? get key;
  @override
  String? get value;
  @override
  @JsonKey(ignore: true)
  _$$GenderImplCopyWith<_$GenderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Protector _$ProtectorFromJson(Map<String, dynamic> json) {
  return _Protector.fromJson(json);
}

/// @nodoc
mixin _$Protector {
  int? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ProtectorCopyWith<Protector> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProtectorCopyWith<$Res> {
  factory $ProtectorCopyWith(Protector value, $Res Function(Protector) then) =
      _$ProtectorCopyWithImpl<$Res, Protector>;
  @useResult
  $Res call({int? id, String? name});
}

/// @nodoc
class _$ProtectorCopyWithImpl<$Res, $Val extends Protector>
    implements $ProtectorCopyWith<$Res> {
  _$ProtectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProtectorImplCopyWith<$Res>
    implements $ProtectorCopyWith<$Res> {
  factory _$$ProtectorImplCopyWith(
          _$ProtectorImpl value, $Res Function(_$ProtectorImpl) then) =
      __$$ProtectorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? id, String? name});
}

/// @nodoc
class __$$ProtectorImplCopyWithImpl<$Res>
    extends _$ProtectorCopyWithImpl<$Res, _$ProtectorImpl>
    implements _$$ProtectorImplCopyWith<$Res> {
  __$$ProtectorImplCopyWithImpl(
      _$ProtectorImpl _value, $Res Function(_$ProtectorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_$ProtectorImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ProtectorImpl implements _Protector {
  const _$ProtectorImpl({this.id, this.name});

  factory _$ProtectorImpl.fromJson(Map<String, dynamic> json) =>
      _$$ProtectorImplFromJson(json);

  @override
  final int? id;
  @override
  final String? name;

  @override
  String toString() {
    return 'Protector(id: $id, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProtectorImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProtectorImplCopyWith<_$ProtectorImpl> get copyWith =>
      __$$ProtectorImplCopyWithImpl<_$ProtectorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ProtectorImplToJson(
      this,
    );
  }
}

abstract class _Protector implements Protector {
  const factory _Protector({final int? id, final String? name}) =
      _$ProtectorImpl;

  factory _Protector.fromJson(Map<String, dynamic> json) =
      _$ProtectorImpl.fromJson;

  @override
  int? get id;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$ProtectorImplCopyWith<_$ProtectorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BloodGroup _$BloodGroupFromJson(Map<String, dynamic> json) {
  return _BloodGroup.fromJson(json);
}

/// @nodoc
mixin _$BloodGroup {
  String? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BloodGroupCopyWith<BloodGroup> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BloodGroupCopyWith<$Res> {
  factory $BloodGroupCopyWith(
          BloodGroup value, $Res Function(BloodGroup) then) =
      _$BloodGroupCopyWithImpl<$Res, BloodGroup>;
  @useResult
  $Res call({String? id, String? name});
}

/// @nodoc
class _$BloodGroupCopyWithImpl<$Res, $Val extends BloodGroup>
    implements $BloodGroupCopyWith<$Res> {
  _$BloodGroupCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BloodGroupImplCopyWith<$Res>
    implements $BloodGroupCopyWith<$Res> {
  factory _$$BloodGroupImplCopyWith(
          _$BloodGroupImpl value, $Res Function(_$BloodGroupImpl) then) =
      __$$BloodGroupImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? id, String? name});
}

/// @nodoc
class __$$BloodGroupImplCopyWithImpl<$Res>
    extends _$BloodGroupCopyWithImpl<$Res, _$BloodGroupImpl>
    implements _$$BloodGroupImplCopyWith<$Res> {
  __$$BloodGroupImplCopyWithImpl(
      _$BloodGroupImpl _value, $Res Function(_$BloodGroupImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_$BloodGroupImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BloodGroupImpl implements _BloodGroup {
  const _$BloodGroupImpl({this.id, this.name});

  factory _$BloodGroupImpl.fromJson(Map<String, dynamic> json) =>
      _$$BloodGroupImplFromJson(json);

  @override
  final String? id;
  @override
  final String? name;

  @override
  String toString() {
    return 'BloodGroup(id: $id, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BloodGroupImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BloodGroupImplCopyWith<_$BloodGroupImpl> get copyWith =>
      __$$BloodGroupImplCopyWithImpl<_$BloodGroupImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BloodGroupImplToJson(
      this,
    );
  }
}

abstract class _BloodGroup implements BloodGroup {
  const factory _BloodGroup({final String? id, final String? name}) =
      _$BloodGroupImpl;

  factory _BloodGroup.fromJson(Map<String, dynamic> json) =
      _$BloodGroupImpl.fromJson;

  @override
  String? get id;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$BloodGroupImplCopyWith<_$BloodGroupImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MaritalStatus _$MaritalStatusFromJson(Map<String, dynamic> json) {
  return _MaritalStatus.fromJson(json);
}

/// @nodoc
mixin _$MaritalStatus {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MaritalStatusCopyWith<MaritalStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaritalStatusCopyWith<$Res> {
  factory $MaritalStatusCopyWith(
          MaritalStatus value, $Res Function(MaritalStatus) then) =
      _$MaritalStatusCopyWithImpl<$Res, MaritalStatus>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$MaritalStatusCopyWithImpl<$Res, $Val extends MaritalStatus>
    implements $MaritalStatusCopyWith<$Res> {
  _$MaritalStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MaritalStatusImplCopyWith<$Res>
    implements $MaritalStatusCopyWith<$Res> {
  factory _$$MaritalStatusImplCopyWith(
          _$MaritalStatusImpl value, $Res Function(_$MaritalStatusImpl) then) =
      __$$MaritalStatusImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$MaritalStatusImplCopyWithImpl<$Res>
    extends _$MaritalStatusCopyWithImpl<$Res, _$MaritalStatusImpl>
    implements _$$MaritalStatusImplCopyWith<$Res> {
  __$$MaritalStatusImplCopyWithImpl(
      _$MaritalStatusImpl _value, $Res Function(_$MaritalStatusImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$MaritalStatusImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MaritalStatusImpl implements _MaritalStatus {
  const _$MaritalStatusImpl({this.key, this.name});

  factory _$MaritalStatusImpl.fromJson(Map<String, dynamic> json) =>
      _$$MaritalStatusImplFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'MaritalStatus(key: $key, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaritalStatusImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MaritalStatusImplCopyWith<_$MaritalStatusImpl> get copyWith =>
      __$$MaritalStatusImplCopyWithImpl<_$MaritalStatusImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MaritalStatusImplToJson(
      this,
    );
  }
}

abstract class _MaritalStatus implements MaritalStatus {
  const factory _MaritalStatus({final String? key, final String? name}) =
      _$MaritalStatusImpl;

  factory _MaritalStatus.fromJson(Map<String, dynamic> json) =
      _$MaritalStatusImpl.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$MaritalStatusImplCopyWith<_$MaritalStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AcademicLevel _$AcademicLevelFromJson(Map<String, dynamic> json) {
  return _AcademicLevel.fromJson(json);
}

/// @nodoc
mixin _$AcademicLevel {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AcademicLevelCopyWith<AcademicLevel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AcademicLevelCopyWith<$Res> {
  factory $AcademicLevelCopyWith(
          AcademicLevel value, $Res Function(AcademicLevel) then) =
      _$AcademicLevelCopyWithImpl<$Res, AcademicLevel>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$AcademicLevelCopyWithImpl<$Res, $Val extends AcademicLevel>
    implements $AcademicLevelCopyWith<$Res> {
  _$AcademicLevelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AcademicLevelImplCopyWith<$Res>
    implements $AcademicLevelCopyWith<$Res> {
  factory _$$AcademicLevelImplCopyWith(
          _$AcademicLevelImpl value, $Res Function(_$AcademicLevelImpl) then) =
      __$$AcademicLevelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$AcademicLevelImplCopyWithImpl<$Res>
    extends _$AcademicLevelCopyWithImpl<$Res, _$AcademicLevelImpl>
    implements _$$AcademicLevelImplCopyWith<$Res> {
  __$$AcademicLevelImplCopyWithImpl(
      _$AcademicLevelImpl _value, $Res Function(_$AcademicLevelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$AcademicLevelImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AcademicLevelImpl implements _AcademicLevel {
  const _$AcademicLevelImpl({this.key, this.name});

  factory _$AcademicLevelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AcademicLevelImplFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'AcademicLevel(key: $key, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AcademicLevelImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AcademicLevelImplCopyWith<_$AcademicLevelImpl> get copyWith =>
      __$$AcademicLevelImplCopyWithImpl<_$AcademicLevelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AcademicLevelImplToJson(
      this,
    );
  }
}

abstract class _AcademicLevel implements AcademicLevel {
  const factory _AcademicLevel({final String? key, final String? name}) =
      _$AcademicLevelImpl;

  factory _AcademicLevel.fromJson(Map<String, dynamic> json) =
      _$AcademicLevelImpl.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$AcademicLevelImplCopyWith<_$AcademicLevelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Interest _$InterestFromJson(Map<String, dynamic> json) {
  return _Interest.fromJson(json);
}

/// @nodoc
mixin _$Interest {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InterestCopyWith<Interest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InterestCopyWith<$Res> {
  factory $InterestCopyWith(Interest value, $Res Function(Interest) then) =
      _$InterestCopyWithImpl<$Res, Interest>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$InterestCopyWithImpl<$Res, $Val extends Interest>
    implements $InterestCopyWith<$Res> {
  _$InterestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InterestImplCopyWith<$Res>
    implements $InterestCopyWith<$Res> {
  factory _$$InterestImplCopyWith(
          _$InterestImpl value, $Res Function(_$InterestImpl) then) =
      __$$InterestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$InterestImplCopyWithImpl<$Res>
    extends _$InterestCopyWithImpl<$Res, _$InterestImpl>
    implements _$$InterestImplCopyWith<$Res> {
  __$$InterestImplCopyWithImpl(
      _$InterestImpl _value, $Res Function(_$InterestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$InterestImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InterestImpl implements _Interest {
  const _$InterestImpl({this.key, this.name});

  factory _$InterestImpl.fromJson(Map<String, dynamic> json) =>
      _$$InterestImplFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'Interest(key: $key, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InterestImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InterestImplCopyWith<_$InterestImpl> get copyWith =>
      __$$InterestImplCopyWithImpl<_$InterestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InterestImplToJson(
      this,
    );
  }
}

abstract class _Interest implements Interest {
  const factory _Interest({final String? key, final String? name}) =
      _$InterestImpl;

  factory _Interest.fromJson(Map<String, dynamic> json) =
      _$InterestImpl.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$InterestImplCopyWith<_$InterestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AutocompleteOption _$AutocompleteOptionFromJson(Map<String, dynamic> json) {
  return _AutocompleteOption.fromJson(json);
}

/// @nodoc
mixin _$AutocompleteOption {
  String? get displayText => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AutocompleteOptionCopyWith<AutocompleteOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AutocompleteOptionCopyWith<$Res> {
  factory $AutocompleteOptionCopyWith(
          AutocompleteOption value, $Res Function(AutocompleteOption) then) =
      _$AutocompleteOptionCopyWithImpl<$Res, AutocompleteOption>;
  @useResult
  $Res call({String? displayText, String? key});
}

/// @nodoc
class _$AutocompleteOptionCopyWithImpl<$Res, $Val extends AutocompleteOption>
    implements $AutocompleteOptionCopyWith<$Res> {
  _$AutocompleteOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayText = freezed,
    Object? key = freezed,
  }) {
    return _then(_value.copyWith(
      displayText: freezed == displayText
          ? _value.displayText
          : displayText // ignore: cast_nullable_to_non_nullable
              as String?,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AutocompleteOptionImplCopyWith<$Res>
    implements $AutocompleteOptionCopyWith<$Res> {
  factory _$$AutocompleteOptionImplCopyWith(_$AutocompleteOptionImpl value,
          $Res Function(_$AutocompleteOptionImpl) then) =
      __$$AutocompleteOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? displayText, String? key});
}

/// @nodoc
class __$$AutocompleteOptionImplCopyWithImpl<$Res>
    extends _$AutocompleteOptionCopyWithImpl<$Res, _$AutocompleteOptionImpl>
    implements _$$AutocompleteOptionImplCopyWith<$Res> {
  __$$AutocompleteOptionImplCopyWithImpl(_$AutocompleteOptionImpl _value,
      $Res Function(_$AutocompleteOptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayText = freezed,
    Object? key = freezed,
  }) {
    return _then(_$AutocompleteOptionImpl(
      displayText: freezed == displayText
          ? _value.displayText
          : displayText // ignore: cast_nullable_to_non_nullable
              as String?,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AutocompleteOptionImpl implements _AutocompleteOption {
  const _$AutocompleteOptionImpl({this.displayText, this.key});

  factory _$AutocompleteOptionImpl.fromJson(Map<String, dynamic> json) =>
      _$$AutocompleteOptionImplFromJson(json);

  @override
  final String? displayText;
  @override
  final String? key;

  @override
  String toString() {
    return 'AutocompleteOption(displayText: $displayText, key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AutocompleteOptionImpl &&
            (identical(other.displayText, displayText) ||
                other.displayText == displayText) &&
            (identical(other.key, key) || other.key == key));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, displayText, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AutocompleteOptionImplCopyWith<_$AutocompleteOptionImpl> get copyWith =>
      __$$AutocompleteOptionImplCopyWithImpl<_$AutocompleteOptionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AutocompleteOptionImplToJson(
      this,
    );
  }
}

abstract class _AutocompleteOption implements AutocompleteOption {
  const factory _AutocompleteOption(
      {final String? displayText,
      final String? key}) = _$AutocompleteOptionImpl;

  factory _AutocompleteOption.fromJson(Map<String, dynamic> json) =
      _$AutocompleteOptionImpl.fromJson;

  @override
  String? get displayText;
  @override
  String? get key;
  @override
  @JsonKey(ignore: true)
  _$$AutocompleteOptionImplCopyWith<_$AutocompleteOptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Talent _$TalentFromJson(Map<String, dynamic> json) {
  return _Talent.fromJson(json);
}

/// @nodoc
mixin _$Talent {
  String? get key => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TalentCopyWith<Talent> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TalentCopyWith<$Res> {
  factory $TalentCopyWith(Talent value, $Res Function(Talent) then) =
      _$TalentCopyWithImpl<$Res, Talent>;
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class _$TalentCopyWithImpl<$Res, $Val extends Talent>
    implements $TalentCopyWith<$Res> {
  _$TalentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TalentImplCopyWith<$Res> implements $TalentCopyWith<$Res> {
  factory _$$TalentImplCopyWith(
          _$TalentImpl value, $Res Function(_$TalentImpl) then) =
      __$$TalentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? name});
}

/// @nodoc
class __$$TalentImplCopyWithImpl<$Res>
    extends _$TalentCopyWithImpl<$Res, _$TalentImpl>
    implements _$$TalentImplCopyWith<$Res> {
  __$$TalentImplCopyWithImpl(
      _$TalentImpl _value, $Res Function(_$TalentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? name = freezed,
  }) {
    return _then(_$TalentImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TalentImpl implements _Talent {
  const _$TalentImpl({this.key, this.name});

  factory _$TalentImpl.fromJson(Map<String, dynamic> json) =>
      _$$TalentImplFromJson(json);

  @override
  final String? key;
  @override
  final String? name;

  @override
  String toString() {
    return 'Talent(key: $key, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TalentImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, key, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TalentImplCopyWith<_$TalentImpl> get copyWith =>
      __$$TalentImplCopyWithImpl<_$TalentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TalentImplToJson(
      this,
    );
  }
}

abstract class _Talent implements Talent {
  const factory _Talent({final String? key, final String? name}) = _$TalentImpl;

  factory _Talent.fromJson(Map<String, dynamic> json) = _$TalentImpl.fromJson;

  @override
  String? get key;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$TalentImplCopyWith<_$TalentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
